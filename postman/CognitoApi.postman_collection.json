{
	"info": {
		"_postman_id": "82c48468-f87f-4c01-99ef-c5c261af0064",
		"name": "CognitoApi",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "28378500"
	},
	"item": [
		{
			"name": "User Authentication",
			"item": [
				{
					"name": "User Login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var jsonData = pm.response.json();",
									"pm.environment.set(\"VerificationSession\", jsonData.verification_session);",
									"pm.environment.set(\"VerificationType\", jsonData.verification_type);",
									"",
									"//Article about TOTP on my blog https://stapp.space/generate-totp-in-postman/",
									"",
									"/**",
									" * @preserve A JavaScript implementation of the SHA family of hashes, as",
									" * defined in FIPS PUB 180-4 and FIPS PUB 202, as well as the corresponding",
									" * HMAC implementation as defined in FIPS PUB 198a",
									" *",
									"pm.environment.get(\"variable_key\");",
									" * Copyright Brian Turek 2008-2017",
									" * Distributed under the BSD License",
									" * See http://caligatio.github.com/jsSHA/ for more information",
									" *",
									" * Several functions taken from Paul Johnston",
									" */",
									"",
									"/*jslint",
									"\tbitwise: true, multivar: true, for: true, this: true, sub: true, esversion: 3",
									"*/",
									"",
									" /**",
									"  * SUPPORTED_ALGS is the stub for a compile flag that will cause pruning of",
									"  * functions that are not needed when a limited number of SHA families are",
									"  * selected",
									"  *",
									"  * @define {number} ORed value of SHA variants to be supported",
									"  *   1 = SHA-1, 2 = SHA-224/SHA-256, 4 = SHA-384/SHA-512, 8 = SHA3",
									"  */",
									"var SUPPORTED_ALGS = 8 | 4 | 2 | 1;",
									"var X={};",
									"",
									"(function (global)",
									"{",
									"\t\"use strict\";",
									"",
									"\t/* Globals */",
									"\tvar TWO_PWR_32 = 4294967296;",
									"",
									"\t/**",
									"\t * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number",
									"\t *",
									"\t * @private",
									"\t * @constructor",
									"\t * @this {Int_64}",
									"\t * @param {number} msint_32 The most significant 32-bits of a 64-bit number",
									"\t * @param {number} lsint_32 The least significant 32-bits of a 64-bit number",
									"\t */",
									"\tfunction Int_64(msint_32, lsint_32)",
									"\t{",
									"\t\tthis.highOrder = msint_32;",
									"\t\tthis.lowOrder = lsint_32;",
									"\t}",
									"",
									"\t/**",
									"\t * Convert a string to an array of big-endian words",
									"\t *",
									"\t * There is a known bug with an odd number of existing bytes and using a",
									"\t * UTF-16 encoding.  However, this function is used such that the existing",
									"\t * bytes are always a result of a previous UTF-16 str2packed call and",
									"\t * therefore there should never be an odd number of existing bytes",
									"\t *",
									"\t * @private",
									"\t * @param {string} str String to be converted to binary representation",
									"\t * @param {string} utfType The Unicode type, UTF8 or UTF16BE, UTF16LE, to",
									"\t *   use to encode the source string",
									"\t * @param {Array<number>} existingPacked A packed int array of bytes to",
									"\t *   append the results to",
									"\t * @param {number} existingPackedLen The number of bits in the existingPacked",
									"\t *   array",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t *   length of \"value\"",
									"\t */",
									"\tfunction str2packed(str, utfType, existingPacked, existingPackedLen, bigEndianMod)",
									"\t{",
									"\t\tvar packed, codePnt, codePntArr, byteCnt = 0, i, j, existingByteLen,",
									"\t\t\tintOffset, byteOffset, shiftModifier, transposeBytes;",
									"",
									"\t\tpacked = existingPacked || [0];",
									"\t\texistingPackedLen = existingPackedLen || 0;",
									"\t\texistingByteLen = existingPackedLen >>> 3;",
									"",
									"\t\tif (\"UTF8\" === utfType)",
									"\t\t{",
									"\t\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"\t\t\tfor (i = 0; i < str.length; i += 1)",
									"\t\t\t{",
									"\t\t\t\tcodePnt = str.charCodeAt(i);",
									"\t\t\t\tcodePntArr = [];",
									"",
									"\t\t\t\tif (0x80 > codePnt)",
									"\t\t\t\t{",
									"\t\t\t\t\tcodePntArr.push(codePnt);",
									"\t\t\t\t}",
									"\t\t\t\telse if (0x800 > codePnt)",
									"\t\t\t\t{",
									"\t\t\t\t\tcodePntArr.push(0xC0 | (codePnt >>> 6));",
									"\t\t\t\t\tcodePntArr.push(0x80 | (codePnt & 0x3F));",
									"\t\t\t\t}",
									"\t\t\t\telse if ((0xd800 > codePnt) || (0xe000 <= codePnt)) {",
									"\t\t\t\t\tcodePntArr.push(",
									"\t\t\t\t\t\t0xe0 | (codePnt >>> 12),",
									"\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),",
									"\t\t\t\t\t\t0x80 | (codePnt & 0x3f)",
									"\t\t\t\t\t);",
									"\t\t\t\t}",
									"\t\t\t\telse",
									"\t\t\t\t{",
									"\t\t\t\t\ti += 1;",
									"\t\t\t\t\tcodePnt = 0x10000 + (((codePnt & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));",
									"\t\t\t\t\tcodePntArr.push(",
									"\t\t\t\t\t\t0xf0 | (codePnt >>> 18),",
									"\t\t\t\t\t\t0x80 | ((codePnt >>> 12) & 0x3f),",
									"\t\t\t\t\t\t0x80 | ((codePnt >>> 6) & 0x3f),",
									"\t\t\t\t\t\t0x80 | (codePnt & 0x3f)",
									"\t\t\t\t\t);",
									"\t\t\t\t}",
									"",
									"\t\t\t\tfor (j = 0; j < codePntArr.length; j += 1)",
									"\t\t\t\t{",
									"\t\t\t\t\tbyteOffset = byteCnt + existingByteLen;",
									"\t\t\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\t\t\twhile (packed.length <= intOffset)",
									"\t\t\t\t\t{",
									"\t\t\t\t\t\tpacked.push(0);",
									"\t\t\t\t\t}",
									"\t\t\t\t\t/* Known bug kicks in here */",
									"\t\t\t\t\tpacked[intOffset] |= codePntArr[j] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t\t\t\tbyteCnt += 1;",
									"\t\t\t\t}",
									"\t\t\t}",
									"\t\t}",
									"\t\telse if ((\"UTF16BE\" === utfType) || \"UTF16LE\" === utfType)",
									"\t\t{",
									"\t\t\tshiftModifier = (bigEndianMod === -1) ? 2 : 0;",
									"\t\t\t/* Internally strings are UTF-16BE so transpose bytes under two conditions:",
									"\t\t\t\t* need LE and not switching endianness due to SHA-3",
									"\t\t\t\t* need BE and switching endianness due to SHA-3 */",
									"\t\t\ttransposeBytes = ((\"UTF16LE\" === utfType) && (bigEndianMod !== 1)) || ((\"UTF16LE\" !== utfType) && (bigEndianMod === 1));",
									"\t\t\tfor (i = 0; i < str.length; i += 1)",
									"\t\t\t{",
									"\t\t\t\tcodePnt = str.charCodeAt(i);",
									"\t\t\t\tif (transposeBytes === true)",
									"\t\t\t\t{",
									"\t\t\t\t\tj = codePnt & 0xFF;",
									"\t\t\t\t\tcodePnt = (j << 8) | (codePnt >>> 8);",
									"\t\t\t\t}",
									"",
									"\t\t\t\tbyteOffset = byteCnt + existingByteLen;",
									"\t\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\t\twhile (packed.length <= intOffset)",
									"\t\t\t\t{",
									"\t\t\t\t\tpacked.push(0);",
									"\t\t\t\t}",
									"\t\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t\t\tbyteCnt += 2;",
									"\t\t\t}",
									"\t\t}",
									"\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};",
									"\t}",
									"",
									"\t/**",
									"\t * Convert a hex string to an array of big-endian words",
									"\t *",
									"\t * @private",
									"\t * @param {string} str String to be converted to binary representation",
									"\t * @param {Array<number>} existingPacked A packed int array of bytes to",
									"\t *   append the results to",
									"\t * @param {number} existingPackedLen The number of bits in the existingPacked",
									"\t *   array",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t *   length of \"value\"",
									"\t */",
									"\tfunction hex2packed(str, existingPacked, existingPackedLen, bigEndianMod)",
									"\t{",
									"\t\tvar packed, length = str.length, i, num, intOffset, byteOffset,",
									"\t\t\texistingByteLen, shiftModifier;",
									"",
									"\t\tif (0 !== (length % 2))",
									"\t\t{",
									"\t\t\tthrow new Error(\"String of HEX type must be in byte increments\");",
									"\t\t}",
									"",
									"\t\tpacked = existingPacked || [0];",
									"\t\texistingPackedLen = existingPackedLen || 0;",
									"\t\texistingByteLen = existingPackedLen >>> 3;",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < length; i += 2)",
									"\t\t{",
									"\t\t\tnum = parseInt(str.substr(i, 2), 16);",
									"\t\t\tif (!isNaN(num))",
									"\t\t\t{",
									"\t\t\t\tbyteOffset = (i >>> 1) + existingByteLen;",
									"\t\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\t\twhile (packed.length <= intOffset)",
									"\t\t\t\t{",
									"\t\t\t\t\tpacked.push(0);",
									"\t\t\t\t}",
									"\t\t\t\tpacked[intOffset] |= num  << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t\t}",
									"\t\t\telse",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"String of HEX type contains invalid characters\");",
									"\t\t\t}",
									"\t\t}",
									"",
									"\t\treturn {\"value\" : packed, \"binLen\" : length * 4 + existingPackedLen};",
									"\t}",
									"",
									"\t/**",
									"\t * Convert a string of raw bytes to an array of big-endian words",
									"\t *",
									"\t * @private",
									"\t * @param {string} str String of raw bytes to be converted to binary representation",
									"\t * @param {Array<number>} existingPacked A packed int array of bytes to",
									"\t *   append the results to",
									"\t * @param {number} existingPackedLen The number of bits in the existingPacked",
									"\t *   array",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t *   length of \"value\"",
									"\t */",
									"\tfunction bytes2packed(str, existingPacked, existingPackedLen, bigEndianMod)",
									"\t{",
									"\t\tvar packed, codePnt, i, existingByteLen, intOffset,",
									"\t\t\tbyteOffset, shiftModifier;",
									"",
									"\t\tpacked = existingPacked || [0];",
									"\t\texistingPackedLen = existingPackedLen || 0;",
									"\t\texistingByteLen = existingPackedLen >>> 3;",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < str.length; i += 1)",
									"\t\t{",
									"\t\t\tcodePnt = str.charCodeAt(i);",
									"",
									"\t\t\tbyteOffset = i + existingByteLen;",
									"\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\tif (packed.length <= intOffset)",
									"\t\t\t{",
									"\t\t\t\tpacked.push(0);",
									"\t\t\t}",
									"\t\t\tpacked[intOffset] |= codePnt << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t}",
									"",
									"\t\treturn {\"value\" : packed, \"binLen\" : str.length * 8 + existingPackedLen};",
									"\t}",
									"",
									"\t/**",
									"\t * Convert a base-64 string to an array of big-endian words",
									"\t *",
									"\t * @private",
									"\t * @param {string} str String to be converted to binary representation",
									"\t * @param {Array<number>} existingPacked A packed int array of bytes to",
									"\t *   append the results to",
									"\t * @param {number} existingPackedLen The number of bits in the existingPacked",
									"\t *   array",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t *   length of \"value\"",
									"\t */",
									"\tfunction b642packed(str, existingPacked, existingPackedLen, bigEndianMod)",
									"\t{",
									"\t\tvar packed, byteCnt = 0, index, i, j, tmpInt, strPart, firstEqual,",
									"\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",",
									"\t\t\texistingByteLen, intOffset, byteOffset, shiftModifier;",
									"",
									"\t\tif (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/))",
									"\t\t{",
									"\t\t\tthrow new Error(\"Invalid character in base-64 string\");",
									"\t\t}",
									"",
									"\t\tfirstEqual = str.indexOf(\"=\");",
									"\t\tstr = str.replace(/\\=/g, \"\");",
									"\t\tif ((-1 !== firstEqual) && (firstEqual < str.length))",
									"\t\t{",
									"\t\t\tthrow new Error(\"Invalid '=' found in base-64 string\");",
									"\t\t}",
									"",
									"\t\tpacked = existingPacked || [0];",
									"\t\texistingPackedLen = existingPackedLen || 0;",
									"\t\texistingByteLen = existingPackedLen >>> 3;",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < str.length; i += 4)",
									"\t\t{",
									"\t\t\tstrPart = str.substr(i, 4);",
									"\t\t\ttmpInt = 0;",
									"",
									"\t\t\tfor (j = 0; j < strPart.length; j += 1)",
									"\t\t\t{",
									"\t\t\t\tindex = b64Tab.indexOf(strPart[j]);",
									"\t\t\t\ttmpInt |= index << (18 - (6 * j));",
									"\t\t\t}",
									"",
									"\t\t\tfor (j = 0; j < strPart.length - 1; j += 1)",
									"\t\t\t{",
									"\t\t\t\tbyteOffset = byteCnt + existingByteLen;",
									"\t\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\t\twhile (packed.length <= intOffset)",
									"\t\t\t\t{",
									"\t\t\t\t\tpacked.push(0);",
									"\t\t\t\t}",
									"\t\t\t\tpacked[intOffset] |= ((tmpInt >>> (16 - (j * 8))) & 0xFF) <<",
									"\t\t\t\t\t(8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t\t\tbyteCnt += 1;",
									"\t\t\t}",
									"\t\t}",
									"",
									"\t\treturn {\"value\" : packed, \"binLen\" : byteCnt * 8 + existingPackedLen};",
									"\t}",
									"",
									"\t/**",
									"\t * Convert an ArrayBuffer to an array of big-endian words",
									"\t *",
									"\t * @private",
									"\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary",
									"\t *   representation",
									"\t * @param {Array<number>} existingPacked A packed int array of bytes to",
									"\t *   append the results to",
									"\t * @param {number} existingPackedLen The number of bits in the existingPacked",
									"\t *   array",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t *   length of \"value\"",
									"\t */",
									"\tfunction arraybuffer2packed(arr, existingPacked, existingPackedLen, bigEndianMod)",
									"\t{",
									"\t\tvar packed, i, existingByteLen, intOffset, byteOffset, shiftModifier, arrView;",
									"",
									"\t\tpacked = existingPacked || [0];",
									"\t\texistingPackedLen = existingPackedLen || 0;",
									"\t\texistingByteLen = existingPackedLen >>> 3;",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"\t\tarrView = new Uint8Array(arr);",
									"",
									"\t\tfor (i = 0; i < arr.byteLength; i += 1)",
									"\t\t{",
									"\t\t\tbyteOffset = i + existingByteLen;",
									"\t\t\tintOffset = byteOffset >>> 2;",
									"\t\t\tif (packed.length <= intOffset)",
									"\t\t\t{",
									"\t\t\t\tpacked.push(0);",
									"\t\t\t}",
									"\t\t\tpacked[intOffset] |= arrView[i] << (8 * (shiftModifier + bigEndianMod * (byteOffset % 4)));",
									"\t\t}",
									"",
									"\t\treturn {\"value\" : packed, \"binLen\" : arr.byteLength * 8 + existingPackedLen};",
									"\t}",
									"",
									"\t/**",
									"\t * Convert an array of big-endian words to a hex string.",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} packed Array of integers to be converted to",
									"\t *   hexidecimal representation",
									"\t * @param {number} outputLength Length of output in bits",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list",
									"\t *   containing validated output formatting options",
									"\t * @return {string} Hexidecimal representation of the parameter in string",
									"\t *   form",
									"\t */",
									"\tfunction packed2hex(packed, outputLength, bigEndianMod, formatOpts)",
									"\t{",
									"\t\tvar hex_tab = \"0123456789abcdef\", str = \"\",",
									"\t\t\tlength = outputLength / 8, i, srcByte, shiftModifier;",
									"",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < length; i += 1)",
									"\t\t{",
									"\t\t\t/* The below is more than a byte but it gets taken care of later */",
									"\t\t\tsrcByte = packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)));",
									"\t\t\tstr += hex_tab.charAt((srcByte >>> 4) & 0xF) +",
									"\t\t\t\thex_tab.charAt(srcByte & 0xF);",
									"\t\t}",
									"",
									"\t\treturn (formatOpts[\"outputUpper\"]) ? str.toUpperCase() : str;",
									"\t}",
									"",
									"\t/**",
									"\t * Convert an array of big-endian words to a base-64 string",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} packed Array of integers to be converted to",
									"\t *   base-64 representation",
									"\t * @param {number} outputLength Length of output in bits",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list",
									"\t *   containing validated output formatting options",
									"\t * @return {string} Base-64 encoded representation of the parameter in",
									"\t *   string form",
									"\t */",
									"\tfunction packed2b64(packed, outputLength, bigEndianMod, formatOpts)",
									"\t{",
									"\t\tvar str = \"\", length = outputLength / 8, i, j, triplet, int1, int2, shiftModifier,",
									"\t\t\tb64Tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
									"",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < length; i += 3)",
									"\t\t{",
									"\t\t\tint1 = ((i + 1) < length) ? packed[(i + 1) >>> 2] : 0;",
									"\t\t\tint2 = ((i + 2) < length) ? packed[(i + 2) >>> 2] : 0;",
									"\t\t\ttriplet = (((packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF) << 16) |",
									"\t\t\t\t(((int1 >>> (8 * (shiftModifier + bigEndianMod * ((i + 1) % 4)))) & 0xFF) << 8) |",
									"\t\t\t\t((int2 >>> (8 * (shiftModifier + bigEndianMod * ((i + 2) % 4)))) & 0xFF);",
									"\t\t\tfor (j = 0; j < 4; j += 1)",
									"\t\t\t{",
									"\t\t\t\tif (i * 8 + j * 6 <= outputLength)",
									"\t\t\t\t{",
									"\t\t\t\t\tstr += b64Tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);",
									"\t\t\t\t}",
									"\t\t\t\telse",
									"\t\t\t\t{",
									"\t\t\t\t\tstr += formatOpts[\"b64Pad\"];",
									"\t\t\t\t}",
									"\t\t\t}",
									"\t\t}",
									"\t\treturn str;",
									"\t}",
									"",
									"\t/**",
									"\t * Convert an array of big-endian words to raw bytes string",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} packed Array of integers to be converted to",
									"\t *   a raw bytes string representation",
									"\t * @param {number} outputLength Length of output in bits",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {string} Raw bytes representation of the parameter in string",
									"\t *   form",
									"\t */",
									"\tfunction packed2bytes(packed, outputLength, bigEndianMod)",
									"\t{",
									"\t\tvar str = \"\", length = outputLength / 8, i, srcByte, shiftModifier;",
									"",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < length; i += 1)",
									"\t\t{",
									"\t\t\tsrcByte = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;",
									"\t\t\tstr += String.fromCharCode(srcByte);",
									"\t\t}",
									"",
									"\t\treturn str;",
									"\t}",
									"",
									"\t/**",
									"\t * Convert an array of big-endian words to an ArrayBuffer",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} packed Array of integers to be converted to",
									"\t *   an ArrayBuffer",
									"\t * @param {number} outputLength Length of output in bits",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {ArrayBuffer} Raw bytes representation of the parameter in an",
									"\t *   ArrayBuffer",
									"\t */",
									"\tfunction packed2arraybuffer(packed, outputLength, bigEndianMod)",
									"\t{",
									"\t\tvar length = outputLength / 8, i, retVal = new ArrayBuffer(length), shiftModifier, arrView;",
									"\t\tarrView = new Uint8Array(retVal);",
									"",
									"\t\tshiftModifier = (bigEndianMod === -1) ? 3 : 0;",
									"",
									"\t\tfor (i = 0; i < length; i += 1)",
									"\t\t{",
									"\t\t\tarrView[i] = (packed[i >>> 2] >>> (8 * (shiftModifier + bigEndianMod * (i % 4)))) & 0xFF;",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * Validate hash list containing output formatting options, ensuring",
									"\t * presence of every option or adding the default value",
									"\t *",
									"\t * @private",
									"\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),",
									"\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options",
									"\t * @return {{outputUpper : boolean, b64Pad : string, shakeLen : number}} Validated",
									"\t *   hash list containing output formatting options",
									"\t */",
									"\tfunction getOutputOpts(options)",
									"\t{",
									"\t\tvar retVal = {\"outputUpper\" : false, \"b64Pad\" : \"=\", \"shakeLen\" : -1},",
									"\t\t\toutputOptions;",
									"\t\toutputOptions = options || {};",
									"",
									"\t\tretVal[\"outputUpper\"] = outputOptions[\"outputUpper\"] || false;",
									"",
									"\t\tif (true === outputOptions.hasOwnProperty(\"b64Pad\"))",
									"\t\t{",
									"\t\t\tretVal[\"b64Pad\"] = outputOptions[\"b64Pad\"];",
									"\t\t}",
									"",
									"\t\tif ((true === outputOptions.hasOwnProperty(\"shakeLen\")) && ((8 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tif (outputOptions[\"shakeLen\"] % 8 !== 0)",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"shakeLen must be a multiple of 8\");",
									"\t\t\t}",
									"\t\t\tretVal[\"shakeLen\"] = outputOptions[\"shakeLen\"];",
									"\t\t}",
									"",
									"\t\tif (\"boolean\" !== typeof(retVal[\"outputUpper\"]))",
									"\t\t{",
									"\t\t\tthrow new Error(\"Invalid outputUpper formatting option\");",
									"\t\t}",
									"",
									"\t\tif (\"string\" !== typeof(retVal[\"b64Pad\"]))",
									"\t\t{",
									"\t\t\tthrow new Error(\"Invalid b64Pad formatting option\");",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * Function that takes an input format and UTF encoding and returns the",
									"\t * appropriate function used to convert the input.",
									"\t *",
									"\t * @private",
									"\t * @param {string} format The format of the string to be converted",
									"\t * @param {string} utfType The string encoding to use (UTF8, UTF16BE,",
									"\t *\tUTF16LE)",
									"\t * @param {number} bigEndianMod Modifier for whether hash function is",
									"\t *   big or small endian",
									"\t * @return {function((string|ArrayBuffer), Array<number>=, number=): {value :",
									"\t *   Array<number>, binLen : number}} Function that will convert an input",
									"\t *   string to a packed int array",
									"\t */",
									"\tfunction getStrConverter(format, utfType, bigEndianMod)",
									"\t{",
									"\t\tvar retVal;",
									"",
									"\t\t/* Validate encoding */",
									"\t\tswitch (utfType)",
									"\t\t{",
									"\t\tcase \"UTF8\":",
									"\t\t\t/* Fallthrough */",
									"\t\tcase \"UTF16BE\":",
									"\t\t\t/* Fallthrough */",
									"\t\tcase \"UTF16LE\":",
									"\t\t\t/* Fallthrough */",
									"\t\t\tbreak;",
									"\t\tdefault:",
									"\t\t\tthrow new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\");",
									"\t\t}",
									"",
									"\t\t/* Map inputFormat to the appropriate converter */",
									"\t\tswitch (format)",
									"\t\t{",
									"\t\tcase \"HEX\":",
									"\t\t\t/**",
									"\t\t\t * @param {string} str String of raw bytes to be converted to binary representation",
									"\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to",
									"\t\t\t *   append the results to",
									"\t\t\t * @param {number} existingBinLen The number of bits in the existingBin",
									"\t\t\t *   array",
									"\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t\t\t *   length of \"value\"",
									"\t\t\t */",
									"\t\t\tretVal = function(str, existingBin, existingBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t   return hex2packed(str, existingBin, existingBinLen, bigEndianMod);",
									"\t\t\t\t};",
									"\t\t\tbreak;",
									"\t\tcase \"TEXT\":",
									"\t\t\t/**",
									"\t\t\t * @param {string} str String of raw bytes to be converted to binary representation",
									"\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to",
									"\t\t\t *   append the results to",
									"\t\t\t * @param {number} existingBinLen The number of bits in the existingBin",
									"\t\t\t *   array",
									"\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t\t\t *   length of \"value\"",
									"\t\t\t */",
									"\t\t\tretVal = function(str, existingBin, existingBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t\treturn str2packed(str, utfType, existingBin, existingBinLen, bigEndianMod);",
									"\t\t\t\t};",
									"\t\t\tbreak;",
									"\t\tcase \"B64\":",
									"\t\t\t/**",
									"\t\t\t * @param {string} str String of raw bytes to be converted to binary representation",
									"\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to",
									"\t\t\t *   append the results to",
									"\t\t\t * @param {number} existingBinLen The number of bits in the existingBin",
									"\t\t\t *   array",
									"\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t\t\t *   length of \"value\"",
									"\t\t\t */",
									"\t\t\tretVal = function(str, existingBin, existingBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t   return b642packed(str, existingBin, existingBinLen, bigEndianMod);",
									"\t\t\t\t};",
									"\t\t\tbreak;",
									"\t\tcase \"BYTES\":",
									"\t\t\t/**",
									"\t\t\t * @param {string} str String of raw bytes to be converted to binary representation",
									"\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to",
									"\t\t\t *   append the results to",
									"\t\t\t * @param {number} existingBinLen The number of bits in the existingBin",
									"\t\t\t *   array",
									"\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t\t\t *   length of \"value\"",
									"\t\t\t */",
									"\t\t\tretVal = function(str, existingBin, existingBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t   return bytes2packed(str, existingBin, existingBinLen, bigEndianMod);",
									"\t\t\t\t};",
									"\t\t\tbreak;",
									"\t\tcase \"ARRAYBUFFER\":",
									"\t\t\ttry {",
									"\t\t\t\tretVal = new ArrayBuffer(0);",
									"\t\t\t} catch(ignore) {",
									"\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");",
									"\t\t\t}",
									"\t\t\t/**",
									"\t\t\t * @param {ArrayBuffer} arr ArrayBuffer to be converted to binary",
									"\t\t\t *   representation",
									"\t\t\t * @param {Array<number>} existingBin A packed int array of bytes to",
									"\t\t\t *   append the results to",
									"\t\t\t * @param {number} existingBinLen The number of bits in the existingBin",
									"\t\t\t *   array",
									"\t\t\t * @return {{value : Array<number>, binLen : number}} Hash list where",
									"\t\t\t *   \"value\" contains the output number array and \"binLen\" is the binary",
									"\t\t\t *   length of \"value\"",
									"\t\t\t */",
									"\t\t\tretVal = function(arr, existingBin, existingBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t   return arraybuffer2packed(arr, existingBin, existingBinLen, bigEndianMod);",
									"\t\t\t\t};",
									"\t\t\tbreak;",
									"\t\tdefault:",
									"\t\t\tthrow new Error(\"format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER\");",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of circular rotate left",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {number} The x shifted circularly by n bits",
									"\t */",
									"\tfunction rotl_32(x, n)",
									"\t{",
									"\t\treturn (x << n) | (x >>> (32 - n));",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of circular rotate left",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {Int_64} The x shifted circularly by n bits",
									"\t */",
									"\tfunction rotl_64(x, n)",
									"\t{",
									"\t\tif (n > 32)",
									"\t\t{",
									"\t\t\tn = n - 32;",
									"\t\t\treturn new Int_64(",
									"\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n),",
									"\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n)",
									"\t\t\t);",
									"\t\t}",
									"\t\telse if (0 !== n)",
									"\t\t{",
									"\t\t\treturn new Int_64(",
									"\t\t\t\tx.highOrder << n | x.lowOrder >>> (32 - n),",
									"\t\t\t\tx.lowOrder << n | x.highOrder >>> (32 - n)",
									"\t\t\t);",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\treturn x;",
									"\t\t}",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of circular rotate right",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {number} The x shifted circularly by n bits",
									"\t */",
									"\tfunction rotr_32(x, n)",
									"\t{",
									"\t\treturn (x >>> n) | (x << (32 - n));",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of circular rotate right",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {Int_64} The x shifted circularly by n bits",
									"\t */",
									"\tfunction rotr_64(x, n)",
									"\t{",
									"\t\tvar retVal = null, tmp = new Int_64(x.highOrder, x.lowOrder);",
									"",
									"\t\tif (32 >= n)",
									"\t\t{",
									"\t\t\tretVal = new Int_64(",
									"\t\t\t\t\t(tmp.highOrder >>> n) | ((tmp.lowOrder << (32 - n)) & 0xFFFFFFFF),",
									"\t\t\t\t\t(tmp.lowOrder >>> n) | ((tmp.highOrder << (32 - n)) & 0xFFFFFFFF)",
									"\t\t\t\t);",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tretVal = new Int_64(",
									"\t\t\t\t\t(tmp.lowOrder >>> (n - 32)) | ((tmp.highOrder << (64 - n)) & 0xFFFFFFFF),",
									"\t\t\t\t\t(tmp.highOrder >>> (n - 32)) | ((tmp.lowOrder << (64 - n)) & 0xFFFFFFFF)",
									"\t\t\t\t);",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of shift right",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {number} The x shifted by n bits",
									"\t */",
									"\tfunction shr_32(x, n)",
									"\t{",
									"\t\treturn x >>> n;",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of shift right",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @param {number} n The number of bits to shift",
									"\t * @return {Int_64} The x shifted by n bits",
									"\t */",
									"\tfunction shr_64(x, n)",
									"\t{",
									"\t\tvar retVal = null;",
									"",
									"\t\tif (32 >= n)",
									"\t\t{",
									"\t\t\tretVal = new Int_64(",
									"\t\t\t\t\tx.highOrder >>> n,",
									"\t\t\t\t\tx.lowOrder >>> n | ((x.highOrder << (32 - n)) & 0xFFFFFFFF)",
									"\t\t\t\t);",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tretVal = new Int_64(",
									"\t\t\t\t\t0,",
									"\t\t\t\t\tx.highOrder >>> (n - 32)",
									"\t\t\t\t);",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Parity function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The first 32-bit integer argument",
									"\t * @param {number} y The second 32-bit integer argument",
									"\t * @param {number} z The third 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction parity_32(x, y, z)",
									"\t{",
									"\t\treturn x ^ y ^ z;",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Ch function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The first 32-bit integer argument",
									"\t * @param {number} y The second 32-bit integer argument",
									"\t * @param {number} z The third 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction ch_32(x, y, z)",
									"\t{",
									"\t\treturn (x & y) ^ (~x & z);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Ch function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The first 64-bit integer argument",
									"\t * @param {Int_64} y The second 64-bit integer argument",
									"\t * @param {Int_64} z The third 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction ch_64(x, y, z)",
									"\t{",
									"\t\treturn new Int_64(",
									"\t\t\t\t(x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),",
									"\t\t\t\t(x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)",
									"\t\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Maj function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The first 32-bit integer argument",
									"\t * @param {number} y The second 32-bit integer argument",
									"\t * @param {number} z The third 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction maj_32(x, y, z)",
									"\t{",
									"\t\treturn (x & y) ^ (x & z) ^ (y & z);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Maj function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The first 64-bit integer argument",
									"\t * @param {Int_64} y The second 64-bit integer argument",
									"\t * @param {Int_64} z The third 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction maj_64(x, y, z)",
									"\t{",
									"\t\treturn new Int_64(",
									"\t\t\t\t(x.highOrder & y.highOrder) ^",
									"\t\t\t\t(x.highOrder & z.highOrder) ^",
									"\t\t\t\t(y.highOrder & z.highOrder),",
									"\t\t\t\t(x.lowOrder & y.lowOrder) ^",
									"\t\t\t\t(x.lowOrder & z.lowOrder) ^",
									"\t\t\t\t(y.lowOrder & z.lowOrder)",
									"\t\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Sigma0 function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction sigma0_32(x)",
									"\t{",
									"\t\treturn rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Sigma0 function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction sigma0_64(x)",
									"\t{",
									"\t\tvar rotr28 = rotr_64(x, 28), rotr34 = rotr_64(x, 34),",
									"\t\t\trotr39 = rotr_64(x, 39);",
									"",
									"\t\treturn new Int_64(",
									"\t\t\t\trotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,",
									"\t\t\t\trotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Sigma1 function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction sigma1_32(x)",
									"\t{",
									"\t\treturn rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Sigma1 function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction sigma1_64(x)",
									"\t{",
									"\t\tvar rotr14 = rotr_64(x, 14), rotr18 = rotr_64(x, 18),",
									"\t\t\trotr41 = rotr_64(x, 41);",
									"",
									"\t\treturn new Int_64(",
									"\t\t\t\trotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,",
									"\t\t\t\trotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Gamma0 function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction gamma0_32(x)",
									"\t{",
									"\t\treturn rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Gamma0 function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction gamma0_64(x)",
									"\t{",
									"\t\tvar rotr1 = rotr_64(x, 1), rotr8 = rotr_64(x, 8), shr7 = shr_64(x, 7);",
									"",
									"\t\treturn new Int_64(",
									"\t\t\t\trotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,",
									"\t\t\t\trotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder",
									"\t\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * The 32-bit implementation of the NIST specified Gamma1 function",
									"\t *",
									"\t * @private",
									"\t * @param {number} x The 32-bit integer argument",
									"\t * @return {number} The NIST specified output of the function",
									"\t */",
									"\tfunction gamma1_32(x)",
									"\t{",
									"\t\treturn rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);",
									"\t}",
									"",
									"\t/**",
									"\t * The 64-bit implementation of the NIST specified Gamma1 function",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The 64-bit integer argument",
									"\t * @return {Int_64} The NIST specified output of the function",
									"\t */",
									"\tfunction gamma1_64(x)",
									"\t{",
									"\t\tvar rotr19 = rotr_64(x, 19), rotr61 = rotr_64(x, 61),",
									"\t\t\tshr6 = shr_64(x, 6);",
									"",
									"\t\treturn new Int_64(",
									"\t\t\t\trotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,",
									"\t\t\t\trotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder",
									"\t\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {number} a The first 32-bit integer argument to be added",
									"\t * @param {number} b The second 32-bit integer argument to be added",
									"\t * @return {number} The sum of a + b",
									"\t */",
									"\tfunction safeAdd_32_2(a, b)",
									"\t{",
									"\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF),",
									"\t\t\tmsw = (a >>> 16) + (b >>> 16) + (lsw >>> 16);",
									"",
									"\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"\t}",
									"",
									"\t/**",
									"\t * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {number} a The first 32-bit integer argument to be added",
									"\t * @param {number} b The second 32-bit integer argument to be added",
									"\t * @param {number} c The third 32-bit integer argument to be added",
									"\t * @param {number} d The fourth 32-bit integer argument to be added",
									"\t * @return {number} The sum of a + b + c + d",
									"\t */",
									"\tfunction safeAdd_32_4(a, b, c, d)",
									"\t{",
									"\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),",
									"\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +",
									"\t\t\t\t(lsw >>> 16);",
									"",
									"\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"\t}",
									"",
									"\t/**",
									"\t * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {number} a The first 32-bit integer argument to be added",
									"\t * @param {number} b The second 32-bit integer argument to be added",
									"\t * @param {number} c The third 32-bit integer argument to be added",
									"\t * @param {number} d The fourth 32-bit integer argument to be added",
									"\t * @param {number} e The fifth 32-bit integer argument to be added",
									"\t * @return {number} The sum of a + b + c + d + e",
									"\t */",
									"\tfunction safeAdd_32_5(a, b, c, d, e)",
									"\t{",
									"\t\tvar lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +",
									"\t\t\t\t(e & 0xFFFF),",
									"\t\t\tmsw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +",
									"\t\t\t\t(e >>> 16) + (lsw >>> 16);",
									"",
									"\t\treturn ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"\t}",
									"",
									"\t/**",
									"\t * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} x The first 64-bit integer argument to be added",
									"\t * @param {Int_64} y The second 64-bit integer argument to be added",
									"\t * @return {Int_64} The sum of x + y",
									"\t */",
									"\tfunction safeAdd_64_2(x, y)",
									"\t{",
									"\t\tvar lsw, msw, lowOrder, highOrder;",
									"",
									"\t\tlsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);",
									"\t\tmsw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);",
									"\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\tlsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);",
									"\t\tmsw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);",
									"\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\treturn new Int_64(highOrder, lowOrder);",
									"\t}",
									"",
									"\t/**",
									"\t * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} a The first 64-bit integer argument to be added",
									"\t * @param {Int_64} b The second 64-bit integer argument to be added",
									"\t * @param {Int_64} c The third 64-bit integer argument to be added",
									"\t * @param {Int_64} d The fouth 64-bit integer argument to be added",
									"\t * @return {Int_64} The sum of a + b + c + d",
									"\t */",
									"\tfunction safeAdd_64_4(a, b, c, d)",
									"\t{",
									"\t\tvar lsw, msw, lowOrder, highOrder;",
									"",
									"\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +",
									"\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);",
									"\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +",
									"\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);",
									"\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +",
									"\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);",
									"\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +",
									"\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);",
									"\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\treturn new Int_64(highOrder, lowOrder);",
									"\t}",
									"",
									"\t/**",
									"\t * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations",
									"\t * internally to work around bugs in some JS interpreters.",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} a The first 64-bit integer argument to be added",
									"\t * @param {Int_64} b The second 64-bit integer argument to be added",
									"\t * @param {Int_64} c The third 64-bit integer argument to be added",
									"\t * @param {Int_64} d The fouth 64-bit integer argument to be added",
									"\t * @param {Int_64} e The fouth 64-bit integer argument to be added",
									"\t * @return {Int_64} The sum of a + b + c + d + e",
									"\t */",
									"\tfunction safeAdd_64_5(a, b, c, d, e)",
									"\t{",
									"\t\tvar lsw, msw, lowOrder, highOrder;",
									"",
									"\t\tlsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +",
									"\t\t\t(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +",
									"\t\t\t(e.lowOrder & 0xFFFF);",
									"\t\tmsw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +",
									"\t\t\t(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +",
									"\t\t\t(lsw >>> 16);",
									"\t\tlowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\tlsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +",
									"\t\t\t(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +",
									"\t\t\t(e.highOrder & 0xFFFF) + (msw >>> 16);",
									"\t\tmsw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +",
									"\t\t\t(c.highOrder >>> 16) + (d.highOrder >>> 16) +",
									"\t\t\t(e.highOrder >>> 16) + (lsw >>> 16);",
									"\t\thighOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);",
									"",
									"\t\treturn new Int_64(highOrder, lowOrder);",
									"\t}",
									"",
									"\t/**",
									"\t * XORs two given arguments.",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} a First argument to be XORed",
									"\t * @param {Int_64} b Second argument to be XORed",
									"\t * @return {Int_64} The XOR of the arguments",
									"\t */",
									"\tfunction xor_64_2(a, b)",
									"\t{",
									"\t\treturn new Int_64(",
									"\t\t\ta.highOrder ^ b.highOrder,",
									"\t\t\ta.lowOrder ^ b.lowOrder",
									"\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * XORs five given arguments.",
									"\t *",
									"\t * @private",
									"\t * @param {Int_64} a First argument to be XORed",
									"\t * @param {Int_64} b Second argument to be XORed",
									"\t * @param {Int_64} c Third argument to be XORed",
									"\t * @param {Int_64} d Fourth argument to be XORed",
									"\t * @param {Int_64} e Fifth argument to be XORed",
									"\t * @return {Int_64} The XOR of the arguments",
									"\t */",
									"\tfunction xor_64_5(a, b, c, d, e)",
									"\t{",
									"\t\treturn new Int_64(",
									"\t\t\ta.highOrder ^ b.highOrder ^ c.highOrder ^ d.highOrder ^ e.highOrder,",
									"\t\t\ta.lowOrder ^ b.lowOrder ^ c.lowOrder ^ d.lowOrder ^ e.lowOrder",
									"\t\t);",
									"\t}",
									"",
									"\t/**",
									"\t * Returns a clone of the given SHA3 state",
									"\t *",
									"\t * @private",
									"\t * @param {Array<Array<Int_64>>} state The state to be cloned",
									"\t * @return {Array<Array<Int_64>>} The cloned state",
									"\t */",
									"\tfunction cloneSHA3State(state) {",
									"\t\tvar clone = [], i;",
									"\t\tfor (i = 0; i < 5; i += 1)",
									"\t\t{",
									"\t\t\tclone[i] = state[i].slice();",
									"\t\t}",
									"",
									"\t\treturn clone;",
									"\t}",
									"",
									"\t/**",
									"\t * Gets the state values for the specified SHA variant",
									"\t *",
									"\t * @param {string} variant The SHA variant",
									"\t * @return {Array<number|Int_64|Array<null>>} The initial state values",
									"\t */",
									"\tfunction getNewState(variant)",
									"\t{",
									"\t\tvar retVal = [], H_trunc, H_full, i;",
									"",
									"\t\tif ((\"SHA-1\" === variant) && ((1 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tretVal = [",
									"\t\t\t\t0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0",
									"\t\t\t];",
									"\t\t}",
									"\t\telse if ((variant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tH_trunc = [",
									"\t\t\t\t0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,",
									"\t\t\t\t0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4",
									"\t\t\t];",
									"\t\t\tH_full = [",
									"\t\t\t\t0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,",
									"\t\t\t\t0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19",
									"\t\t\t];",
									"",
									"\t\t\tswitch (variant)",
									"\t\t\t{",
									"\t\t\tcase \"SHA-224\":",
									"\t\t\t\tretVal = H_trunc;",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"SHA-256\":",
									"\t\t\t\tretVal = H_full;",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"SHA-384\":",
									"\t\t\t\tretVal = [",
									"\t\t\t\t\tnew Int_64(0xcbbb9d5d, H_trunc[0]),",
									"\t\t\t\t\tnew Int_64(0x0629a292a, H_trunc[1]),",
									"\t\t\t\t\tnew Int_64(0x9159015a, H_trunc[2]),",
									"\t\t\t\t\tnew Int_64(0x0152fecd8, H_trunc[3]),",
									"\t\t\t\t\tnew Int_64(0x67332667, H_trunc[4]),",
									"\t\t\t\t\tnew Int_64(0x98eb44a87, H_trunc[5]),",
									"\t\t\t\t\tnew Int_64(0xdb0c2e0d, H_trunc[6]),",
									"\t\t\t\t\tnew Int_64(0x047b5481d, H_trunc[7])",
									"\t\t\t\t];",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"SHA-512\":",
									"\t\t\t\tretVal = [",
									"\t\t\t\t\tnew Int_64(H_full[0], 0xf3bcc908),",
									"\t\t\t\t\tnew Int_64(H_full[1], 0x84caa73b),",
									"\t\t\t\t\tnew Int_64(H_full[2], 0xfe94f82b),",
									"\t\t\t\t\tnew Int_64(H_full[3], 0x5f1d36f1),",
									"\t\t\t\t\tnew Int_64(H_full[4], 0xade682d1),",
									"\t\t\t\t\tnew Int_64(H_full[5], 0x2b3e6c1f),",
									"\t\t\t\t\tnew Int_64(H_full[6], 0xfb41bd6b),",
									"\t\t\t\t\tnew Int_64(H_full[7], 0x137e2179)",
									"\t\t\t\t];",
									"\t\t\t\tbreak;",
									"\t\t\tdefault:",
									"\t\t\t\tthrow new Error(\"Unknown SHA variant\");",
									"\t\t\t}",
									"\t\t}",
									"\t\telse if (((variant.lastIndexOf(\"SHA3-\", 0) === 0) || (variant.lastIndexOf(\"SHAKE\", 0) === 0)) &&",
									"\t\t\t((8 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tfor (i = 0; i < 5; i += 1)",
									"\t\t\t{",
									"\t\t\t\tretVal[i] = [new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0), new Int_64(0, 0)];",
									"\t\t\t}",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tthrow new Error(\"No SHA variants supported\");",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * Performs a round of SHA-1 hashing over a 512-byte block",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} block The binary array representation of the",
									"\t *   block to hash",
									"\t * @param {Array<number>} H The intermediate H values from a previous",
									"\t *   round",
									"\t * @return {Array<number>} The resulting H values",
									"\t */",
									"\tfunction roundSHA1(block, H)",
									"\t{",
									"\t\tvar W = [], a, b, c, d, e, T, ch = ch_32, parity = parity_32,",
									"\t\t\tmaj = maj_32, rotl = rotl_32, safeAdd_2 = safeAdd_32_2, t,",
									"\t\t\tsafeAdd_5 = safeAdd_32_5;",
									"",
									"\t\ta = H[0];",
									"\t\tb = H[1];",
									"\t\tc = H[2];",
									"\t\td = H[3];",
									"\t\te = H[4];",
									"",
									"\t\tfor (t = 0; t < 80; t += 1)",
									"\t\t{",
									"\t\t\tif (t < 16)",
									"\t\t\t{",
									"\t\t\t\tW[t] = block[t];",
									"\t\t\t}",
									"\t\t\telse",
									"\t\t\t{",
									"\t\t\t\tW[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);",
									"\t\t\t}",
									"",
									"\t\t\tif (t < 20)",
									"\t\t\t{",
									"\t\t\t\tT = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 0x5a827999, W[t]);",
									"\t\t\t}",
									"\t\t\telse if (t < 40)",
									"\t\t\t{",
									"\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0x6ed9eba1, W[t]);",
									"\t\t\t}",
									"\t\t\telse if (t < 60)",
									"\t\t\t{",
									"\t\t\t\tT = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 0x8f1bbcdc, W[t]);",
									"\t\t\t} else {",
									"\t\t\t\tT = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0xca62c1d6, W[t]);",
									"\t\t\t}",
									"",
									"\t\t\te = d;",
									"\t\t\td = c;",
									"\t\t\tc = rotl(b, 30);",
									"\t\t\tb = a;",
									"\t\t\ta = T;",
									"\t\t}",
									"",
									"\t\tH[0] = safeAdd_2(a, H[0]);",
									"\t\tH[1] = safeAdd_2(b, H[1]);",
									"\t\tH[2] = safeAdd_2(c, H[2]);",
									"\t\tH[3] = safeAdd_2(d, H[3]);",
									"\t\tH[4] = safeAdd_2(e, H[4]);",
									"",
									"\t\treturn H;",
									"\t}",
									"",
									"\t/**",
									"\t * Finalizes the SHA-1 hash",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} remainder Any leftover unprocessed packed ints",
									"\t *   that still need to be processed",
									"\t * @param {number} remainderBinLen The number of bits in remainder",
									"\t * @param {number} processedBinLen The number of bits already",
									"\t *   processed",
									"\t * @param {Array<number>} H The intermediate H values from a previous",
									"\t *   round",
									"\t * @param {number} outputLen Unused for this variant",
									"\t * @return {Array<number>} The array of integers representing the SHA-1",
									"\t *   hash of message",
									"\t */",
									"\tfunction finalizeSHA1(remainder, remainderBinLen, processedBinLen, H, outputLen)",
									"\t{",
									"\t\tvar i, appendedMessageLength, offset, totalLen;",
									"",
									"\t\t/* The 65 addition is a hack but it works.  The correct number is",
									"\t\t   actually 72 (64 + 8) but the below math fails if",
									"\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,",
									"\t\t   \"shorting\" the addition is OK. */",
									"\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;",
									"\t\twhile (remainder.length <= offset)",
									"\t\t{",
									"\t\t\tremainder.push(0);",
									"\t\t}",
									"\t\t/* Append '1' at the end of the binary string */",
									"\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));",
									"\t\t/* Append length of binary string in the position such that the new",
									"\t\t * length is a multiple of 512.  Logic does not work for even multiples",
									"\t\t * of 512 but there can never be even multiples of 512. JavaScript",
									"\t\t * numbers are limited to 2^53 so it's \"safe\" to treat the totalLen as",
									"\t\t * a 64-bit integer. */",
									"\t\ttotalLen = remainderBinLen + processedBinLen;",
									"\t\tremainder[offset] = totalLen & 0xFFFFFFFF;",
									"\t\t/* Bitwise operators treat the operand as a 32-bit number so need to",
									"\t\t * use hacky division and round to get access to upper 32-ish bits */",
									"\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;",
									"",
									"\t\tappendedMessageLength = remainder.length;",
									"",
									"\t\t/* This will always be at least 1 full chunk */",
									"\t\tfor (i = 0; i < appendedMessageLength; i += 16)",
									"\t\t{",
									"\t\t\tH = roundSHA1(remainder.slice(i, i + 16), H);",
									"\t\t}",
									"",
									"\t\treturn H;",
									"\t}",
									"",
									"\t/* Put this here so the K arrays aren't put on the stack for every block */",
									"\tvar K_sha2, K_sha512, r_sha3, rc_sha3;",
									"\tif ((6 & SUPPORTED_ALGS) !== 0)",
									"\t{",
									"\t\tK_sha2 = [",
									"\t\t\t0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,",
									"\t\t\t0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,",
									"\t\t\t0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,",
									"\t\t\t0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,",
									"\t\t\t0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,",
									"\t\t\t0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,",
									"\t\t\t0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,",
									"\t\t\t0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,",
									"\t\t\t0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,",
									"\t\t\t0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,",
									"\t\t\t0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,",
									"\t\t\t0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,",
									"\t\t\t0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,",
									"\t\t\t0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,",
									"\t\t\t0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,",
									"\t\t\t0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2",
									"\t\t];",
									"",
									"\t\tif ((4 & SUPPORTED_ALGS) !== 0)",
									"\t\t{",
									"\t\t\t K_sha512 = [",
									"\t\t\t\tnew Int_64(K_sha2[ 0], 0xd728ae22), new Int_64(K_sha2[ 1], 0x23ef65cd),",
									"\t\t\t\tnew Int_64(K_sha2[ 2], 0xec4d3b2f), new Int_64(K_sha2[ 3], 0x8189dbbc),",
									"\t\t\t\tnew Int_64(K_sha2[ 4], 0xf348b538), new Int_64(K_sha2[ 5], 0xb605d019),",
									"\t\t\t\tnew Int_64(K_sha2[ 6], 0xaf194f9b), new Int_64(K_sha2[ 7], 0xda6d8118),",
									"\t\t\t\tnew Int_64(K_sha2[ 8], 0xa3030242), new Int_64(K_sha2[ 9], 0x45706fbe),",
									"\t\t\t\tnew Int_64(K_sha2[10], 0x4ee4b28c), new Int_64(K_sha2[11], 0xd5ffb4e2),",
									"\t\t\t\tnew Int_64(K_sha2[12], 0xf27b896f), new Int_64(K_sha2[13], 0x3b1696b1),",
									"\t\t\t\tnew Int_64(K_sha2[14], 0x25c71235), new Int_64(K_sha2[15], 0xcf692694),",
									"\t\t\t\tnew Int_64(K_sha2[16], 0x9ef14ad2), new Int_64(K_sha2[17], 0x384f25e3),",
									"\t\t\t\tnew Int_64(K_sha2[18], 0x8b8cd5b5), new Int_64(K_sha2[19], 0x77ac9c65),",
									"\t\t\t\tnew Int_64(K_sha2[20], 0x592b0275), new Int_64(K_sha2[21], 0x6ea6e483),",
									"\t\t\t\tnew Int_64(K_sha2[22], 0xbd41fbd4), new Int_64(K_sha2[23], 0x831153b5),",
									"\t\t\t\tnew Int_64(K_sha2[24], 0xee66dfab), new Int_64(K_sha2[25], 0x2db43210),",
									"\t\t\t\tnew Int_64(K_sha2[26], 0x98fb213f), new Int_64(K_sha2[27], 0xbeef0ee4),",
									"\t\t\t\tnew Int_64(K_sha2[28], 0x3da88fc2), new Int_64(K_sha2[29], 0x930aa725),",
									"\t\t\t\tnew Int_64(K_sha2[30], 0xe003826f), new Int_64(K_sha2[31], 0x0a0e6e70),",
									"\t\t\t\tnew Int_64(K_sha2[32], 0x46d22ffc), new Int_64(K_sha2[33], 0x5c26c926),",
									"\t\t\t\tnew Int_64(K_sha2[34], 0x5ac42aed), new Int_64(K_sha2[35], 0x9d95b3df),",
									"\t\t\t\tnew Int_64(K_sha2[36], 0x8baf63de), new Int_64(K_sha2[37], 0x3c77b2a8),",
									"\t\t\t\tnew Int_64(K_sha2[38], 0x47edaee6), new Int_64(K_sha2[39], 0x1482353b),",
									"\t\t\t\tnew Int_64(K_sha2[40], 0x4cf10364), new Int_64(K_sha2[41], 0xbc423001),",
									"\t\t\t\tnew Int_64(K_sha2[42], 0xd0f89791), new Int_64(K_sha2[43], 0x0654be30),",
									"\t\t\t\tnew Int_64(K_sha2[44], 0xd6ef5218), new Int_64(K_sha2[45], 0x5565a910),",
									"\t\t\t\tnew Int_64(K_sha2[46], 0x5771202a), new Int_64(K_sha2[47], 0x32bbd1b8),",
									"\t\t\t\tnew Int_64(K_sha2[48], 0xb8d2d0c8), new Int_64(K_sha2[49], 0x5141ab53),",
									"\t\t\t\tnew Int_64(K_sha2[50], 0xdf8eeb99), new Int_64(K_sha2[51], 0xe19b48a8),",
									"\t\t\t\tnew Int_64(K_sha2[52], 0xc5c95a63), new Int_64(K_sha2[53], 0xe3418acb),",
									"\t\t\t\tnew Int_64(K_sha2[54], 0x7763e373), new Int_64(K_sha2[55], 0xd6b2b8a3),",
									"\t\t\t\tnew Int_64(K_sha2[56], 0x5defb2fc), new Int_64(K_sha2[57], 0x43172f60),",
									"\t\t\t\tnew Int_64(K_sha2[58], 0xa1f0ab72), new Int_64(K_sha2[59], 0x1a6439ec),",
									"\t\t\t\tnew Int_64(K_sha2[60], 0x23631e28), new Int_64(K_sha2[61], 0xde82bde9),",
									"\t\t\t\tnew Int_64(K_sha2[62], 0xb2c67915), new Int_64(K_sha2[63], 0xe372532b),",
									"\t\t\t\tnew Int_64(0xca273ece, 0xea26619c), new Int_64(0xd186b8c7, 0x21c0c207),",
									"\t\t\t\tnew Int_64(0xeada7dd6, 0xcde0eb1e), new Int_64(0xf57d4f7f, 0xee6ed178),",
									"\t\t\t\tnew Int_64(0x06f067aa, 0x72176fba), new Int_64(0x0a637dc5, 0xa2c898a6),",
									"\t\t\t\tnew Int_64(0x113f9804, 0xbef90dae), new Int_64(0x1b710b35, 0x131c471b),",
									"\t\t\t\tnew Int_64(0x28db77f5, 0x23047d84), new Int_64(0x32caab7b, 0x40c72493),",
									"\t\t\t\tnew Int_64(0x3c9ebe0a, 0x15c9bebc), new Int_64(0x431d67c4, 0x9c100d4c),",
									"\t\t\t\tnew Int_64(0x4cc5d4be, 0xcb3e42b6), new Int_64(0x597f299c, 0xfc657e2a),",
									"\t\t\t\tnew Int_64(0x5fcb6fab, 0x3ad6faec), new Int_64(0x6c44198c, 0x4a475817)",
									"\t\t\t];",
									"\t\t}",
									"\t}",
									"\tif ((8 & SUPPORTED_ALGS) !== 0)",
									"\t{",
									"\t\trc_sha3 = [",
									"\t\t\tnew Int_64(0x00000000, 0x00000001), new Int_64(0x00000000, 0x00008082),",
									"\t\t\tnew Int_64(0x80000000, 0x0000808A), new Int_64(0x80000000, 0x80008000),",
									"\t\t\tnew Int_64(0x00000000, 0x0000808B), new Int_64(0x00000000, 0x80000001),",
									"\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008009),",
									"\t\t\tnew Int_64(0x00000000, 0x0000008A), new Int_64(0x00000000, 0x00000088),",
									"\t\t\tnew Int_64(0x00000000, 0x80008009), new Int_64(0x00000000, 0x8000000A),",
									"\t\t\tnew Int_64(0x00000000, 0x8000808B), new Int_64(0x80000000, 0x0000008B),",
									"\t\t\tnew Int_64(0x80000000, 0x00008089), new Int_64(0x80000000, 0x00008003),",
									"\t\t\tnew Int_64(0x80000000, 0x00008002), new Int_64(0x80000000, 0x00000080),",
									"\t\t\tnew Int_64(0x00000000, 0x0000800A), new Int_64(0x80000000, 0x8000000A),",
									"\t\t\tnew Int_64(0x80000000, 0x80008081), new Int_64(0x80000000, 0x00008080),",
									"\t\t\tnew Int_64(0x00000000, 0x80000001), new Int_64(0x80000000, 0x80008008)",
									"\t\t];",
									"",
									"\t\tr_sha3 = [",
									"\t\t\t[ 0, 36,  3, 41, 18],",
									"\t\t\t[ 1, 44, 10, 45,  2],",
									"\t\t\t[62,  6, 43, 15, 61],",
									"\t\t\t[28, 55, 25, 21, 56],",
									"\t\t\t[27, 20, 39,  8, 14]",
									"\t\t];",
									"\t}",
									"",
									"\t/**",
									"\t * Performs a round of SHA-2 hashing over a block",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} block The binary array representation of the",
									"\t *   block to hash",
									"\t * @param {Array<number|Int_64>} H The intermediate H values from a previous",
									"\t *   round",
									"\t * @param {string} variant The desired SHA-2 variant",
									"\t * @return {Array<number|Int_64>} The resulting H values",
									"\t */",
									"\tfunction roundSHA2(block, H, variant)",
									"\t{",
									"\t\tvar a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult,",
									"\t\t\tsafeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1,",
									"\t\t\tch, maj, Int, W = [], int1, int2, offset, K;",
									"",
									"\t\t/* Set up the various function handles and variable for the specific",
									"\t\t * variant */",
									"\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&",
									"\t\t\t((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\t/* 32-bit variant */",
									"\t\t\tnumRounds = 64;",
									"\t\t\tbinaryStringMult = 1;",
									"\t\t\tInt = Number;",
									"\t\t\tsafeAdd_2 = safeAdd_32_2;",
									"\t\t\tsafeAdd_4 = safeAdd_32_4;",
									"\t\t\tsafeAdd_5 = safeAdd_32_5;",
									"\t\t\tgamma0 = gamma0_32;",
									"\t\t\tgamma1 = gamma1_32;",
									"\t\t\tsigma0 = sigma0_32;",
									"\t\t\tsigma1 = sigma1_32;",
									"\t\t\tmaj = maj_32;",
									"\t\t\tch = ch_32;",
									"\t\t\tK = K_sha2;",
									"\t\t}",
									"\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&",
									"\t\t\t((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\t/* 64-bit variant */",
									"\t\t\tnumRounds = 80;",
									"\t\t\tbinaryStringMult = 2;",
									"\t\t\tInt = Int_64;",
									"\t\t\tsafeAdd_2 = safeAdd_64_2;",
									"\t\t\tsafeAdd_4 = safeAdd_64_4;",
									"\t\t\tsafeAdd_5 = safeAdd_64_5;",
									"\t\t\tgamma0 = gamma0_64;",
									"\t\t\tgamma1 = gamma1_64;",
									"\t\t\tsigma0 = sigma0_64;",
									"\t\t\tsigma1 = sigma1_64;",
									"\t\t\tmaj = maj_64;",
									"\t\t\tch = ch_64;",
									"\t\t\tK = K_sha512;",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");",
									"\t\t}",
									"",
									"\t\ta = H[0];",
									"\t\tb = H[1];",
									"\t\tc = H[2];",
									"\t\td = H[3];",
									"\t\te = H[4];",
									"\t\tf = H[5];",
									"\t\tg = H[6];",
									"\t\th = H[7];",
									"",
									"\t\tfor (t = 0; t < numRounds; t += 1)",
									"\t\t{",
									"\t\t\tif (t < 16)",
									"\t\t\t{",
									"\t\t\t\toffset = t * binaryStringMult;",
									"\t\t\t\tint1 = (block.length <= offset) ? 0 : block[offset];",
									"\t\t\t\tint2 = (block.length <= offset + 1) ? 0 : block[offset + 1];",
									"\t\t\t\t/* Bit of a hack - for 32-bit, the second term is ignored */",
									"\t\t\t\tW[t] = new Int(int1, int2);",
									"\t\t\t}",
									"\t\t\telse",
									"\t\t\t{",
									"\t\t\t\tW[t] = safeAdd_4(",
									"\t\t\t\t\t\tgamma1(W[t - 2]), W[t - 7],",
									"\t\t\t\t\t\tgamma0(W[t - 15]), W[t - 16]",
									"\t\t\t\t\t);",
									"\t\t\t}",
									"",
									"\t\t\tT1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);",
									"\t\t\tT2 = safeAdd_2(sigma0(a), maj(a, b, c));",
									"\t\t\th = g;",
									"\t\t\tg = f;",
									"\t\t\tf = e;",
									"\t\t\te = safeAdd_2(d, T1);",
									"\t\t\td = c;",
									"\t\t\tc = b;",
									"\t\t\tb = a;",
									"\t\t\ta = safeAdd_2(T1, T2);",
									"\t\t}",
									"",
									"\t\tH[0] = safeAdd_2(a, H[0]);",
									"\t\tH[1] = safeAdd_2(b, H[1]);",
									"\t\tH[2] = safeAdd_2(c, H[2]);",
									"\t\tH[3] = safeAdd_2(d, H[3]);",
									"\t\tH[4] = safeAdd_2(e, H[4]);",
									"\t\tH[5] = safeAdd_2(f, H[5]);",
									"\t\tH[6] = safeAdd_2(g, H[6]);",
									"\t\tH[7] = safeAdd_2(h, H[7]);",
									"",
									"\t\treturn H;",
									"\t}",
									"",
									"\t/**",
									"\t * Finalizes the SHA-2 hash",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} remainder Any leftover unprocessed packed ints",
									"\t *   that still need to be processed",
									"\t * @param {number} remainderBinLen The number of bits in remainder",
									"\t * @param {number} processedBinLen The number of bits already",
									"\t *   processed",
									"\t * @param {Array<number|Int_64>} H The intermediate H values from a previous",
									"\t *   round",
									"\t * @param {string} variant The desired SHA-2 variant",
									"\t * @param {number} outputLen Unused for this variant",
									"\t * @return {Array<number>} The array of integers representing the SHA-2",
									"\t *   hash of message",
									"\t */",
									"\tfunction finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, variant, outputLen)",
									"\t{",
									"\t\tvar i, appendedMessageLength, offset, retVal, binaryStringInc, totalLen;",
									"",
									"\t\tif ((variant === \"SHA-224\" || variant === \"SHA-256\") &&",
									"\t\t\t((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\t/* 32-bit variant */",
									"\t\t\t/* The 65 addition is a hack but it works.  The correct number is",
									"\t\t\t   actually 72 (64 + 8) but the below math fails if",
									"\t\t\t   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,",
									"\t\t\t   \"shorting\" the addition is OK. */",
									"\t\t\toffset = (((remainderBinLen + 65) >>> 9) << 4) + 15;",
									"\t\t\tbinaryStringInc = 16;",
									"\t\t}",
									"\t\telse if ((variant === \"SHA-384\" || variant === \"SHA-512\") &&",
									"\t\t\t((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\t/* 64-bit variant */",
									"\t\t\t/* The 129 addition is a hack but it works.  The correct number is",
									"\t\t\t   actually 136 (128 + 8) but the below math fails if",
									"\t\t\t   remainderBinLen + 136 % 1024 = 0. Since remainderBinLen % 8 = 0,",
									"\t\t\t   \"shorting\" the addition is OK. */",
									"\t\t\toffset = (((remainderBinLen + 129) >>> 10) << 5) + 31;",
									"\t\t\tbinaryStringInc = 32;",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");",
									"\t\t}",
									"",
									"\t\twhile (remainder.length <= offset)",
									"\t\t{",
									"\t\t\tremainder.push(0);",
									"\t\t}",
									"\t\t/* Append '1' at the end of the binary string */",
									"\t\tremainder[remainderBinLen >>> 5] |= 0x80 << (24 - remainderBinLen % 32);",
									"\t\t/* Append length of binary string in the position such that the new",
									"\t\t * length is correct. JavaScript numbers are limited to 2^53 so it's",
									"\t\t * \"safe\" to treat the totalLen as a 64-bit integer. */",
									"\t\ttotalLen = remainderBinLen + processedBinLen;",
									"\t\tremainder[offset] = totalLen & 0xFFFFFFFF;",
									"\t\t/* Bitwise operators treat the operand as a 32-bit number so need to",
									"\t\t * use hacky division and round to get access to upper 32-ish bits */",
									"\t\tremainder[offset - 1] = (totalLen / TWO_PWR_32) | 0;",
									"",
									"\t\tappendedMessageLength = remainder.length;",
									"",
									"\t\t/* This will always be at least 1 full chunk */",
									"\t\tfor (i = 0; i < appendedMessageLength; i += binaryStringInc)",
									"\t\t{",
									"\t\t\tH = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);",
									"\t\t}",
									"",
									"\t\tif ((\"SHA-224\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tretVal = [",
									"\t\t\t\tH[0], H[1], H[2], H[3],",
									"\t\t\t\tH[4], H[5], H[6]",
									"\t\t\t];",
									"\t\t}",
									"\t\telse if ((\"SHA-256\" === variant) && ((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tretVal = H;",
									"\t\t}",
									"\t\telse if ((\"SHA-384\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tretVal = [",
									"\t\t\t\tH[0].highOrder, H[0].lowOrder,",
									"\t\t\t\tH[1].highOrder, H[1].lowOrder,",
									"\t\t\t\tH[2].highOrder, H[2].lowOrder,",
									"\t\t\t\tH[3].highOrder, H[3].lowOrder,",
									"\t\t\t\tH[4].highOrder, H[4].lowOrder,",
									"\t\t\t\tH[5].highOrder, H[5].lowOrder",
									"\t\t\t];",
									"\t\t}",
									"\t\telse if ((\"SHA-512\" === variant) && ((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tretVal = [",
									"\t\t\t\tH[0].highOrder, H[0].lowOrder,",
									"\t\t\t\tH[1].highOrder, H[1].lowOrder,",
									"\t\t\t\tH[2].highOrder, H[2].lowOrder,",
									"\t\t\t\tH[3].highOrder, H[3].lowOrder,",
									"\t\t\t\tH[4].highOrder, H[4].lowOrder,",
									"\t\t\t\tH[5].highOrder, H[5].lowOrder,",
									"\t\t\t\tH[6].highOrder, H[6].lowOrder,",
									"\t\t\t\tH[7].highOrder, H[7].lowOrder",
									"\t\t\t];",
									"\t\t}",
									"\t\telse /* This should never be reached */",
									"\t\t{",
									"\t\t\tthrow new Error(\"Unexpected error in SHA-2 implementation\");",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * Performs a round of SHA-3 hashing over a block",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>|null} block The binary array representation of the",
									"\t *   block to hash",
									"\t * @param {Array<Array<Int_64>>} state The binary array representation of the",
									"\t *   block to hash",
									"\t * @return {Array<Array<Int_64>>} The resulting state value",
									"\t */",
									"\tfunction roundSHA3(block, state)",
									"\t{",
									"\t\tvar round, x, y, B, C = [], D = [];",
									"",
									"\t\tif (null !== block)",
									"\t\t{",
									"\t\t\tfor (x = 0; x < block.length; x+=2)",
									"\t\t\t{",
									"\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0] = xor_64_2(",
									"\t\t\t\t\tstate[(x >>> 1) % 5][((x >>> 1) / 5) | 0],",
									"\t\t\t\t\tnew Int_64(block[x + 1], block[x])",
									"\t\t\t\t);",
									"\t\t\t}",
									"\t\t}",
									"",
									"\t\tfor (round = 0; round < 24; round += 1)",
									"\t\t{",
									"\t\t\t/* getNewState doesn't care about variant beyond SHA3 so feed it a",
									"\t\t\t   value that triggers the getNewState \"if\" statement",
									"\t\t\t*/",
									"\t\t\tB = getNewState(\"SHA3-\");",
									"",
									"\t\t\t/* Perform theta step */",
									"\t\t\tfor (x = 0; x < 5; x += 1)",
									"\t\t\t{",
									"\t\t\t\tC[x] = xor_64_5(state[x][0], state[x][1], state[x][2],",
									"\t\t\t\t\tstate[x][3], state[x][4]);",
									"\t\t\t}",
									"\t\t\tfor (x = 0; x < 5; x += 1)",
									"\t\t\t{",
									"\t\t\t\tD[x] = xor_64_2(C[(x + 4) % 5], rotl_64(C[(x + 1) % 5], 1));",
									"\t\t\t}",
									"\t\t\tfor (x = 0; x < 5; x += 1)",
									"\t\t\t{",
									"\t\t\t\tfor (y = 0; y < 5; y += 1)",
									"\t\t\t\t{",
									"\t\t\t\t\tstate[x][y] = xor_64_2(state[x][y], D[x]);",
									"\t\t\t\t}",
									"\t\t\t}",
									"",
									"\t\t\t/* Perform combined ro and pi steps */",
									"\t\t\tfor (x = 0; x < 5; x += 1)",
									"\t\t\t{",
									"\t\t\t\tfor (y = 0; y < 5; y += 1)",
									"\t\t\t\t{",
									"\t\t\t\t\tB[y][(2 * x + 3 * y) % 5] = rotl_64(",
									"\t\t\t\t\t\tstate[x][y],",
									"\t\t\t\t\t\tr_sha3[x][y]",
									"\t\t\t\t\t);",
									"\t\t\t\t}",
									"\t\t\t}",
									"",
									"\t\t\t/* Perform chi step */",
									"\t\t\tfor (x = 0; x < 5; x += 1)",
									"\t\t\t{",
									"\t\t\t\tfor (y = 0; y < 5; y += 1)",
									"\t\t\t\t{",
									"\t\t\t\t\tstate[x][y] = xor_64_2(",
									"\t\t\t\t\t\tB[x][y],",
									"\t\t\t\t\t\tnew Int_64(",
									"\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].highOrder) & B[(x + 2) % 5][y].highOrder,",
									"\t\t\t\t\t\t\t~(B[(x + 1) % 5][y].lowOrder)  & B[(x + 2) % 5][y].lowOrder",
									"\t\t\t\t\t\t)",
									"\t\t\t\t\t);",
									"\t\t\t\t}",
									"\t\t\t}",
									"",
									"\t\t\t/* Perform iota step */",
									"\t\t\tstate[0][0] = xor_64_2(state[0][0], rc_sha3[round]);",
									"\t\t}",
									"",
									"\t\treturn state;",
									"\t}",
									"",
									"\t/**",
									"\t * Finalizes the SHA-3 hash",
									"\t *",
									"\t * @private",
									"\t * @param {Array<number>} remainder Any leftover unprocessed packed ints",
									"\t *   that still need to be processed",
									"\t * @param {number} remainderBinLen The number of bits in remainder",
									"\t * @param {number} processedBinLen The number of bits already",
									"\t *   processed",
									"\t * @param {Array<Array<Int_64>>} state The state from a previous round",
									"\t * @param {number} blockSize The block size/rate of the variant in bits",
									"\t * @param {number} delimiter The delimiter value for the variant",
									"\t * @param {number} outputLen The output length for the variant in bits",
									"\t * @return {Array<number>} The array of integers representing the SHA-3",
									"\t *   hash of message",
									"\t */",
									"\tfunction finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, blockSize, delimiter, outputLen)",
									"\t{",
									"\t\tvar i, retVal = [], binaryStringInc = blockSize >>> 5, state_offset = 0,",
									"\t\t\tremainderIntLen = remainderBinLen >>> 5, temp;",
									"",
									"",
									"\t\t/* Process as many blocks as possible, some may be here for multiple rounds",
									"\t\t   with SHAKE",
									"\t\t*/",
									"\t\tfor (i = 0; i < remainderIntLen && remainderBinLen >= blockSize; i += binaryStringInc)",
									"\t\t{",
									"\t\t\tstate = roundSHA3(remainder.slice(i, i + binaryStringInc), state);",
									"\t\t\tremainderBinLen -= blockSize;",
									"\t\t}",
									"",
									"\t\tremainder = remainder.slice(i);",
									"\t\tremainderBinLen = remainderBinLen % blockSize;",
									"",
									"\t\t/* Pad out the remainder to a full block */",
									"\t\twhile (remainder.length < binaryStringInc)",
									"\t\t{",
									"\t\t\tremainder.push(0);",
									"\t\t}",
									"",
									"\t\t/* Find the next \"empty\" byte for the 0x80 and append it via an xor */",
									"\t\ti = remainderBinLen >>> 3;",
									"\t\tremainder[i >> 2] ^= delimiter << (8 * (i % 4));",
									"",
									"\t\tremainder[binaryStringInc - 1] ^= 0x80000000;",
									"\t\tstate = roundSHA3(remainder, state);",
									"",
									"\t\twhile (retVal.length * 32 < outputLen)",
									"\t\t{",
									"\t\t\ttemp = state[state_offset % 5][(state_offset / 5) | 0];",
									"\t\t\tretVal.push(temp.lowOrder);",
									"\t\t\tif (retVal.length * 32 >= outputLen)",
									"\t\t\t{",
									"\t\t\t\tbreak;",
									"\t\t\t}",
									"\t\t\tretVal.push(temp.highOrder);",
									"\t\t\tstate_offset += 1;",
									"",
									"\t\t\tif (0 === ((state_offset * 64) % blockSize))",
									"\t\t\t{",
									"\t\t\t\troundSHA3(null, state);",
									"\t\t\t}",
									"\t\t}",
									"",
									"\t\treturn retVal;",
									"\t}",
									"",
									"\t/**",
									"\t * jsSHA is the workhorse of the library.  Instantiate it with the string to",
									"\t * be hashed as the parameter",
									"\t *",
									"\t * @constructor",
									"\t * @this {jsSHA}",
									"\t * @param {string} variant The desired SHA variant (SHA-1, SHA-224, SHA-256,",
									"\t *   SHA-384, SHA-512, SHA3-224, SHA3-256, SHA3-384, or SHA3-512)",
									"\t * @param {string} inputFormat The format of srcString: HEX, TEXT, B64,",
									"\t *   BYTES, or ARRAYBUFFER",
									"\t * @param {{encoding: (string|undefined), numRounds: (number|undefined)}=}",
									"\t *   options Optional values",
									"\t */",
									"\tvar jsSHA = function(variant, inputFormat, options)",
									"\t{",
									"\t\tvar processedLen = 0, remainder = [], remainderLen = 0, utfType,",
									"\t\t\tintermediateState, converterFunc, shaVariant = variant, outputBinLen,",
									"\t\t\tvariantBlockSize, roundFunc, finalizeFunc, stateCloneFunc,",
									"\t\t\thmacKeySet = false, keyWithIPad = [], keyWithOPad = [], numRounds,",
									"\t\t\tupdatedCalled = false, inputOptions, isSHAKE = false, bigEndianMod = -1;",
									"",
									"\t\tinputOptions = options || {};",
									"\t\tutfType = inputOptions[\"encoding\"] || \"UTF8\";",
									"\t\tnumRounds = inputOptions[\"numRounds\"] || 1;",
									"",
									"\t\tif ((numRounds !== parseInt(numRounds, 10)) || (1 > numRounds))",
									"\t\t{",
									"\t\t\tthrow new Error(\"numRounds must a integer >= 1\");",
									"\t\t}",
									"",
									"\t\tif ((\"SHA-1\" === shaVariant) && ((1 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tvariantBlockSize = 512;",
									"\t\t\troundFunc = roundSHA1;",
									"\t\t\tfinalizeFunc = finalizeSHA1;",
									"\t\t\toutputBinLen = 160;",
									"\t\t\tstateCloneFunc = function(state) { return state.slice();};",
									"\t\t}",
									"\t\telse if ((shaVariant.lastIndexOf(\"SHA-\", 0) === 0) && ((6 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\troundFunc = function (block, H) {",
									"\t\t\t\treturn roundSHA2(block, H, shaVariant);",
									"\t\t\t};",
									"\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, H, outputLen)",
									"\t\t\t{",
									"\t\t\t\treturn finalizeSHA2(remainder, remainderBinLen, processedBinLen, H, shaVariant, outputLen);",
									"\t\t\t};",
									"\t\t\tstateCloneFunc = function(state) { return state.slice(); };",
									"",
									"\t\t\tif ((\"SHA-224\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 512;",
									"\t\t\t\toutputBinLen = 224;",
									"\t\t\t}",
									"\t\t\telse if ((\"SHA-256\" === shaVariant) && ((2 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 512;",
									"\t\t\t\toutputBinLen = 256;",
									"\t\t\t}",
									"\t\t\telse if ((\"SHA-384\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1024;",
									"\t\t\t\toutputBinLen = 384;",
									"\t\t\t}",
									"\t\t\telse if ((\"SHA-512\" === shaVariant) && ((4 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1024;",
									"\t\t\t\toutputBinLen = 512;",
									"\t\t\t}",
									"\t\t\telse",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported \"+shaVariant);",
									"\t\t\t}",
									"\t\t}",
									"\t\telse if (((shaVariant.lastIndexOf(\"SHA3-\", 0) === 0) || (shaVariant.lastIndexOf(\"SHAKE\", 0) === 0)) &&",
									"\t\t\t((8 & SUPPORTED_ALGS) !== 0))",
									"\t\t{",
									"\t\t\tvar delimiter = 0x06;",
									"",
									"\t\t\troundFunc = roundSHA3;",
									"\t\t\tstateCloneFunc = function(state) { return cloneSHA3State(state);};",
									"\t\t\tbigEndianMod = 1;",
									"",
									"\t\t\tif (\"SHA3-224\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1152;",
									"\t\t\t\toutputBinLen = 224;",
									"",
									"\t\t\t}",
									"\t\t\telse if (\"SHA3-256\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1088;",
									"\t\t\t\toutputBinLen = 256;",
									"\t\t\t}",
									"\t\t\telse if (\"SHA3-384\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 832;",
									"\t\t\t\toutputBinLen = 384;",
									"\t\t\t}",
									"\t\t\telse if (\"SHA3-512\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 576;",
									"\t\t\t\toutputBinLen = 512;",
									"\t\t\t}",
									"\t\t\telse if (\"SHAKE128\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1344;",
									"\t\t\t\toutputBinLen = -1;",
									"\t\t\t\tdelimiter = 0x1F;",
									"\t\t\t\tisSHAKE = true;",
									"\t\t\t}",
									"\t\t\telse if (\"SHAKE256\" === shaVariant)",
									"\t\t\t{",
									"\t\t\t\tvariantBlockSize = 1088;",
									"\t\t\t\toutputBinLen = -1;",
									"\t\t\t\tdelimiter = 0x1F;",
									"\t\t\t\tisSHAKE = true;",
									"\t\t\t}",
									"\t\t\telse",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"Chosen SHA variant is not supported \"+shaVariant);",
									"\t\t\t}",
									"\t\t\tfinalizeFunc = function (remainder, remainderBinLen, processedBinLen, state, outputLen)",
									"\t\t\t{",
									"\t\t\t\treturn finalizeSHA3(remainder, remainderBinLen, processedBinLen, state, variantBlockSize, delimiter, outputLen);",
									"\t\t\t};",
									"\t\t}",
									"\t\telse",
									"\t\t{",
									"\t\t\tthrow new Error(\"Chosen SHA varwwwiant is not supported \"+shaVariant);",
									"\t\t}",
									"\t\tconverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);",
									"\t\tintermediateState = getNewState(shaVariant);",
									"",
									"\t\t/**",
									"\t\t * Sets the HMAC key for an eventual getHMAC call.  Must be called",
									"\t\t * immediately after jsSHA object instantiation",
									"\t\t *",
									"\t\t * @expose",
									"\t\t * @param {string|ArrayBuffer} key The key used to calculate the HMAC",
									"\t\t * @param {string} inputFormat The format of key, HEX, TEXT, B64, BYTES,",
									"\t\t *   or ARRAYBUFFER",
									"\t\t * @param {{encoding : (string|undefined)}=} options Associative array",
									"\t\t *   of input format options",
									"\t\t */",
									"\t\tthis.setHMACKey = function(key, inputFormat, options)",
									"\t\t{",
									"\t\t\tvar keyConverterFunc, convertRet, keyBinLen, keyToUse, blockByteSize,",
									"\t\t\t\ti, lastArrayIndex, keyOptions;",
									"",
									"\t\t\tif (true === hmacKeySet)",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"HMAC key already set\");",
									"\t\t\t}",
									"",
									"\t\t\tif (true === updatedCalled)",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"Cannot set HMAC key after calling update\");",
									"\t\t\t}",
									"",
									"\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"SHAKE is not supported for HMAC\");",
									"\t\t\t}",
									"",
									"\t\t\tkeyOptions = options || {};",
									"\t\t\tutfType = keyOptions[\"encoding\"] || \"UTF8\";",
									"",
									"\t\t\tkeyConverterFunc = getStrConverter(inputFormat, utfType, bigEndianMod);",
									"",
									"\t\t\tconvertRet = keyConverterFunc(key);",
									"\t\t\tkeyBinLen = convertRet[\"binLen\"];",
									"\t\t\tkeyToUse = convertRet[\"value\"];",
									"",
									"\t\t\tblockByteSize = variantBlockSize >>> 3;",
									"",
									"\t\t\t/* These are used multiple times, calculate and store them */",
									"\t\t\tlastArrayIndex = (blockByteSize / 4) - 1;",
									"",
									"\t\t\t/* Figure out what to do with the key based on its size relative to",
									"\t\t\t * the hash's block size */",
									"\t\t\tif (blockByteSize < (keyBinLen / 8))",
									"\t\t\t{",
									"",
									"\t\t\t\tkeyToUse = finalizeFunc(keyToUse, keyBinLen, 0,getNewState(shaVariant), outputBinLen);",
									"\t\t\t\t/* For all variants, the block size is bigger than the output",
									"\t\t\t\t * size so there will never be a useful byte at the end of the",
									"\t\t\t\t * string */",
									"\t\t\t\twhile (keyToUse.length <= lastArrayIndex)",
									"\t\t\t\t{",
									"\t\t\t\t\tkeyToUse.push(0);",
									"\t\t\t\t}",
									"\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;",
									"\t\t\t}",
									"\t\t\telse if (blockByteSize > (keyBinLen / 8))",
									"\t\t\t{",
									"\t\t\t\t/* If the blockByteSize is greater than the key length, there",
									"\t\t\t\t * will always be at LEAST one \"useless\" byte at the end of the",
									"\t\t\t\t * string */",
									"\t\t\t\twhile (keyToUse.length <= lastArrayIndex)",
									"\t\t\t\t{",
									"\t\t\t\t\tkeyToUse.push(0);",
									"\t\t\t\t}",
									"\t\t\t\tkeyToUse[lastArrayIndex] &= 0xFFFFFF00;",
									"\t\t\t}",
									"",
									"\t\t\t/* Create ipad and opad */",
									"\t\t\tfor (i = 0; i <= lastArrayIndex; i += 1)",
									"\t\t\t{",
									"\t\t\t\tkeyWithIPad[i] = keyToUse[i] ^ 0x36363636;",
									"\t\t\t\tkeyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;",
									"\t\t\t}",
									"",
									"\t\t\tintermediateState = roundFunc(keyWithIPad, intermediateState);",
									"\t\t\tprocessedLen = variantBlockSize;",
									"",
									"\t\t\thmacKeySet = true;",
									"\t\t};",
									"",
									"\t\t/**",
									"\t\t * Takes strString and hashes as many blocks as possible.  Stores the",
									"\t\t * rest for either a future update or getHash call.",
									"\t\t *",
									"\t\t * @expose",
									"\t\t * @param {string|ArrayBuffer} srcString The string to be hashed",
									"\t\t */",
									"\t\tthis.update = function(srcString)",
									"\t\t{",
									"\t\t\tvar convertRet, chunkBinLen, chunkIntLen, chunk, i, updateProcessedLen = 0,",
									"\t\t\t\tvariantBlockIntInc = variantBlockSize >>> 5;",
									"",
									"\t\t\tconvertRet = converterFunc(srcString, remainder, remainderLen);",
									"\t\t\tchunkBinLen = convertRet[\"binLen\"];",
									"\t\t\tchunk = convertRet[\"value\"];",
									"",
									"\t\t\tchunkIntLen = chunkBinLen >>> 5;",
									"\t\t\tfor (i = 0; i < chunkIntLen; i += variantBlockIntInc)",
									"\t\t\t{",
									"\t\t\t\tif (updateProcessedLen + variantBlockSize <= chunkBinLen)",
									"\t\t\t\t{",
									"\t\t\t\t\tintermediateState = roundFunc(",
									"\t\t\t\t\t\tchunk.slice(i, i + variantBlockIntInc),",
									"\t\t\t\t\t\tintermediateState",
									"\t\t\t\t\t);",
									"\t\t\t\t\tupdateProcessedLen += variantBlockSize;",
									"\t\t\t\t}",
									"\t\t\t}",
									"\t\t\tprocessedLen += updateProcessedLen;",
									"\t\t\tremainder = chunk.slice(updateProcessedLen >>> 5);",
									"\t\t\tremainderLen = chunkBinLen % variantBlockSize;",
									"\t\t\tupdatedCalled = true;",
									"",
									"\t\t};",
									"",
									"\t\t/**",
									"\t\t * Returns the desired SHA hash of the string specified at instantiation",
									"\t\t * using the specified parameters",
									"\t\t *",
									"\t\t * @expose",
									"\t\t * @param {string} format The desired output formatting (B64, HEX,",
									"\t\t *   BYTES, or ARRAYBUFFER)",
									"\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),",
									"\t\t *   shakeLen : (number|undefined)}=} options Hash list of output formatting options",
									"\t\t * @return {string|ArrayBuffer} The string representation of the hash",
									"\t\t *   in the format specified.",
									"\t\t */",
									"\t\tthis.getHash = function(format, options)",
									"\t\t{",
									"\t\t\tvar formatFunc, i, outputOptions, finalizedState;",
									"",
									"\t\t\tif (true === hmacKeySet)",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"Cannot call getHash after setting HMAC key\");",
									"\t\t\t}",
									"",
									"\t\t\toutputOptions = getOutputOpts(options);",
									"",
									"\t\t\tif ((isSHAKE === true) && ((8 & SUPPORTED_ALGS) !== 0))",
									"\t\t\t{",
									"\t\t\t\tif (outputOptions[\"shakeLen\"] === -1)",
									"\t\t\t\t{",
									"\t\t\t\t\tthrow new Error(\"shakeLen must be specified in options\");",
									"\t\t\t\t}",
									"\t\t\t\toutputBinLen = outputOptions[\"shakeLen\"];",
									"\t\t\t}",
									"",
									"\t\t\t/* Validate the output format selection */",
									"\t\t\tswitch (format)",
									"\t\t\t{",
									"\t\t\tcase \"HEX\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"B64\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"BYTES\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"ARRAYBUFFER\":",
									"\t\t\t\ttry {",
									"\t\t\t\t\ti = new ArrayBuffer(0);",
									"\t\t\t\t} catch (ignore) {",
									"\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");",
									"\t\t\t\t}",
									"\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};",
									"\t\t\t\tbreak;",
									"\t\t\tdefault:",
									"\t\t\t\tthrow new Error(\"format must be HEX, B64, BYTES, or ARRAYBUFFER\");",
									"\t\t\t}",
									"",
									"\t\t\tfinalizedState = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);",
									"\t\t\tfor (i = 1; i < numRounds; i += 1)",
									"\t\t\t{",
									"\t\t\t\t/* This weird fix-up is only for the case of SHAKE algorithms",
									"\t\t\t\t * and outputBinLen is not a multiple of 32.  In this case, the",
									"\t\t\t\t * very last block of finalizedState has data that needs to be",
									"\t\t\t\t * ignored because all the finalizeFunc calls need to have",
									"\t\t\t\t * unneeded bits set to 0.",
									"\t\t\t\t */",
									"\t\t\t\tif (((8 & SUPPORTED_ALGS) !== 0) && (isSHAKE === true) && (outputBinLen % 32 !== 0))",
									"\t\t\t\t{",
									"\t\t\t\t\tfinalizedState[finalizedState.length - 1] &= 0x00FFFFFF >>> 24 - (outputBinLen % 32);",
									"\t\t\t\t}",
									"\t\t\t\tfinalizedState = finalizeFunc(finalizedState, outputBinLen, 0, getNewState(shaVariant), outputBinLen);",
									"\t\t\t}",
									"",
									"\t\t\treturn formatFunc(finalizedState);",
									"\t\t};",
									"",
									"\t\t/**",
									"\t\t * Returns the the HMAC in the specified format using the key given by",
									"\t\t * a previous setHMACKey call.",
									"\t\t *",
									"\t\t * @expose",
									"\t\t * @param {string} format The desired output formatting",
									"\t\t *   (B64, HEX, BYTES, or ARRAYBUFFER)",
									"\t\t * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined),",
									"\t\t *   shakeLen : (number|undefined)}=} options associative array of output",
									"\t\t *   formatting options",
									"\t\t * @return {string|ArrayBuffer} The string representation of the hash in the",
									"\t\t *   format specified.",
									"\t\t */",
									"\t\tthis.getHMAC = function(format, options)",
									"\t\t{",
									"\t\t\tvar formatFunc,\tfirstHash, outputOptions, finalizedState;",
									"",
									"\t\t\tif (false === hmacKeySet)",
									"\t\t\t{",
									"\t\t\t\tthrow new Error(\"Cannot call getHMAC without first setting HMAC key\");",
									"\t\t\t}",
									"",
									"\t\t\toutputOptions = getOutputOpts(options);",
									"",
									"\t\t\t/* Validate the output format selection */",
									"\t\t\tswitch (format)",
									"\t\t\t{",
									"\t\t\tcase \"HEX\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2hex(binarray, outputBinLen, bigEndianMod, outputOptions);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"B64\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2b64(binarray, outputBinLen, bigEndianMod, outputOptions);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"BYTES\":",
									"\t\t\t\tformatFunc = function(binarray) {return packed2bytes(binarray, outputBinLen, bigEndianMod);};",
									"\t\t\t\tbreak;",
									"\t\t\tcase \"ARRAYBUFFER\":",
									"\t\t\t\ttry {",
									"\t\t\t\t\tformatFunc = new ArrayBuffer(0);",
									"\t\t\t\t} catch(ignore) {",
									"\t\t\t\t\tthrow new Error(\"ARRAYBUFFER not supported by this environment\");",
									"\t\t\t\t}",
									"\t\t\t\tformatFunc = function(binarray) {return packed2arraybuffer(binarray, outputBinLen, bigEndianMod);};",
									"\t\t\t\tbreak;",
									"\t\t\tdefault:",
									"\t\t\t\tthrow new Error(\"outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER\");",
									"\t\t\t}",
									"",
									"\t\t\tfirstHash = finalizeFunc(remainder.slice(), remainderLen, processedLen, stateCloneFunc(intermediateState), outputBinLen);",
									"\t\t\tfinalizedState = roundFunc(keyWithOPad, getNewState(shaVariant));",
									"\t\t\tfinalizedState = finalizeFunc(firstHash, outputBinLen, variantBlockSize, finalizedState, outputBinLen);",
									"",
									"\t\t\treturn formatFunc(finalizedState);",
									"\t\t};",
									"\t};",
									"",
									"\tif ((\"function\" === typeof define) && (define[\"amd\"])) /* AMD Support */",
									"\t{",
									"\t\tdefine(function()",
									"\t\t{",
									"\t\t\treturn jsSHA;",
									"\t\t});",
									"\t} else if (\"undefined\" !== typeof exports) /* Node Support */",
									"\t{",
									"\t\tif ((\"undefined\" !== typeof module) && module[\"exports\"])",
									"\t\t{",
									"\t\t  module[\"exports\"] = jsSHA;",
									"\t\t  exports = jsSHA;",
									"\t\t}",
									"\t\telse {",
									"\t\t\texports = jsSHA;",
									"\t\t}",
									"\t} else { /* Browsers and Web Workers*/",
									"\t\tglobal[\"jsSHA\"] = jsSHA;",
									"\t}",
									"}(X));",
									"",
									"TOTP = function() {",
									"",
									"    var dec2hex = function(s) {",
									"        return (s < 15.5 ? \"0\" : \"\") + Math.round(s).toString(16);",
									"    };",
									"",
									"    var hex2dec = function(s) {",
									"        return parseInt(s, 16);",
									"    };",
									"",
									"    var leftpad = function(s, l, p) {",
									"        if(l + 1 >= s.length) {",
									"            s = Array(l + 1 - s.length).join(p) + s;",
									"        }",
									"        return s;",
									"    };",
									"",
									"    var base32tohex = function(base32) {",
									"        var base32chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";",
									"        var bits = \"\";",
									"        var hex = \"\";",
									"        for(var i = 0; i < base32.length; i++) {",
									"            var val = base32chars.indexOf(base32.charAt(i).toUpperCase());",
									"            bits += leftpad(val.toString(2), 5, '0');",
									"        }",
									"\tfor (i = i % 8; i > 0; i--) {",
									"        \tbits += leftpad('0', 5, '0');",
									"        }",
									"        for (i = 0; i + 4 <= bits.length; i += 4) {",
									"                var chunk = bits.substr(i, 4);",
									"                hex = hex + parseInt(chunk, 2).toString(16);",
									"        }",
									"",
									"        return hex;",
									"    };",
									"",
									"    this.getOTP = function(secret) {",
									"        try {",
									"            var key = base32tohex(secret);",
									"            var epoch = Math.round(new Date().getTime() / 1000.0);",
									"            var time = leftpad(dec2hex(Math.floor(epoch / 30)), 16, \"0\");",
									"            var shaObj = new X.jsSHA(\"SHA-1\", \"HEX\");",
									"            shaObj.setHMACKey(key, \"HEX\");",
									"            shaObj.update(time);",
									"            var hmac = shaObj.getHMAC(\"HEX\");",
									"            var offset = hex2dec(hmac.substring(hmac.length - 1));",
									"            var otp = (hex2dec(hmac.substr(offset * 2, 8)) & hex2dec(\"7fffffff\")) + \"\";",
									"            otp = (otp).substr(otp.length - 6, 6);",
									"        } catch (error) {",
									"            throw error;",
									"        }",
									"        return otp;",
									"    };",
									"",
									"}",
									"",
									"var totpObj = new TOTP();",
									"var otp = totpObj.getOTP(pm.environment.get(\"MFA_SECRET\"));",
									"",
									"pm.environment.set(\"OTP\", otp);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"password\": \"{{PASSWORD}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/login",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "User Logout",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"access_token\": \"{{AccessToken}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/logout",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"logout"
							]
						}
					},
					"response": []
				},
				{
					"name": "Mfa Verify",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var jsonData = pm.response.json();",
									"pm.environment.set(\"AccessToken\", jsonData.access_token);",
									"pm.environment.set(\"IdToken\", jsonData.id_token);",
									"pm.environment.set(\"RefreshToken\", jsonData.refresh_token);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{USER_ID}}\",\n    \"verification_type\": \"{{VerificationType}}\",\n    \"verification_session\": \"{{VerificationSession}}\",\n    \"otp_code\": \"{{OTP}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/mfa-verify",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"mfa-verify"
							]
						}
					},
					"response": []
				},
				{
					"name": "Refresh Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var jsonData = pm.response.json();",
									"pm.environment.set(\"AccessToken\", jsonData.access_token);",
									"pm.environment.set(\"IdToken\", jsonData.id_token);",
									"pm.environment.set(\"RefreshToken\", jsonData.refresh_token);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"refresh_token\": \"{{RefreshToken}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/refresh-token",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"refresh-token"
							]
						}
					},
					"response": []
				},
				{
					"name": "Userinfo",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "Bearer {{IdToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{API_BASE_URL}}/v1/userinfo",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"userinfo"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "User Management Lifecycle",
			"item": [
				{
					"name": "Create User",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"var jsonData = pm.response.json();",
									"pm.environment.set(\"USER_ID\", jsonData.user_id);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"full_name\": \"Tarek CHEIKH\",\n    \"email\": \"{{EMAIL}}\",\n    \"mobile_phone_number\": \"+33610541107\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Confirm New User",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var jsonData = pm.response.json();",
									"pm.environment.set(\"MFA_SECRET\", jsonData.qr_code_secret);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"temporary_password\": \"8YRMtDt2Gpym*Y\",\n    \"new_password\": \"#Y3KdGR9QKg_a9\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}/confirm",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}",
								"confirm"
							]
						}
					},
					"response": []
				},
				{
					"name": "Confirm MFA",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"otp\": \"328802\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}/confirm-mfa",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}",
								"confirm-mfa"
							]
						}
					},
					"response": []
				},
				{
					"name": "Confirm Password",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"new_password\": \"#Y3KdGR9QKg_a9\",\n    \"verification_code\": \"304482\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}/confirm-password",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}",
								"confirm-password"
							]
						}
					},
					"response": []
				},
				{
					"name": "Resend Confirmation Code",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/resend-confirmation-code",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"resend-confirmation-code"
							]
						}
					},
					"response": []
				},
				{
					"name": "Resend MFA",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/resend-mfa",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"resend-mfa"
							]
						}
					},
					"response": []
				},
				{
					"name": "Forgot Password",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/forgot-password",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"forgot-password"
							]
						}
					},
					"response": []
				},
				{
					"name": "Reset Password",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}/reset-password",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}",
								"reset-password"
							]
						}
					},
					"response": []
				},
				{
					"name": "User Change Password",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{EMAIL}}\",\n    \"old_password\":\"zx2y1y0iXvOV|@\",\n    \"new_password\":\"zx3y1y0iXvOV|@\",\n    \"access_token\":\"{{AccessToken}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}/change-password",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}",
								"change-password"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete User",
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "x-api-key",
								"value": "{{API_KEY}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{API_BASE_URL}}/v1/users/{{USER_ID}}",
							"host": [
								"{{API_BASE_URL}}"
							],
							"path": [
								"v1",
								"users",
								"{{USER_ID}}"
							]
						}
					},
					"response": []
				}
			]
		}
	]
}